diff --git a/src/qselect.h b/src/qselect.h
new file mode 100644
index 0000000..1019f38
--- /dev/null
+++ b/src/qselect.h
@@ -0,0 +1,89 @@
+#ifndef QSELECT_H
+#define QSELECT_H
+
+#include <stddef.h>
+#include <stdint.h>
+
+#define _SAFE_INDEX(p,i,s) ((void*)((intptr_t)p+i*s))
+
+typedef int(*__compare_fn_t)(const void*, const void*, void*);
+
+static inline void
+_qselect_memswap(void *restrict p1, void *restrict p2, size_t n)
+{
+  while (n > 0)
+    {
+      unsigned char t = ((unsigned char *)p1)[--n];
+      ((unsigned char *)p1)[n] = ((unsigned char *)p2)[n];
+      ((unsigned char *)p2)[n] = t;
+    }
+}
+
+static size_t 
+_qselect_partition(void* base, size_t size, size_t left, size_t right, size_t pivot_index, __compare_fn_t compare, void* arg)
+{
+	size_t store_index = left;
+
+	void* iptr;
+	void* rptr = _SAFE_INDEX(base,right,size);
+	void* sptr = _SAFE_INDEX(base,store_index,size);
+	void* pptr = _SAFE_INDEX(base,pivot_index,size);
+
+	_qselect_memswap(rptr, pptr, size);
+	for(size_t i=left; i<right; i++)
+	{
+		iptr = _SAFE_INDEX(base,i,size);
+		if (compare(iptr, rptr, arg) <= 0)
+		{
+			_qselect_memswap(iptr, sptr, size);
+			store_index += 1; 
+			sptr = _SAFE_INDEX(base,store_index,size);
+		}
+	}
+	_qselect_memswap(sptr, rptr, size);
+	return store_index;
+}
+
+static size_t 
+_qselect_median3(void* base, size_t size, size_t left, size_t right, __compare_fn_t compare, void* arg)
+{
+	size_t mid = (left + right + 1) / 2;
+
+	const void* lptr = _SAFE_INDEX(base,left,size);
+	const void* rptr = _SAFE_INDEX(base,right,size);
+	const void* mptr = _SAFE_INDEX(base,mid,size);
+
+	if ((compare(lptr, mptr, arg) > 0) != (compare(lptr, rptr,arg) > 0))
+		return left;
+	else if ((compare(mptr, lptr, arg) < 0) != (compare(mptr, rptr, arg) < 0))
+		return mid;
+	else
+		return right;
+}
+
+static size_t 
+qselect_r(void* base, size_t n, size_t size, size_t k, __compare_fn_t compare, void* arg) 
+{
+	size_t pivot_index;
+	size_t left = 0;
+	size_t right = n-1;
+
+	while(1) {
+		if (left == right)
+			return left;
+
+		pivot_index = _qselect_median3(base, size, left, right, compare, arg); 
+		pivot_index = _qselect_partition(base, size, left, right, pivot_index, compare, arg);
+
+		if(pivot_index == k) 
+			return pivot_index;
+		else if (k < pivot_index)
+			right = pivot_index - 1;
+		else
+			left = pivot_index + 1;
+	}
+}
+
+#undef _SAFE_INDEX
+
+#endif
\ No newline at end of file
