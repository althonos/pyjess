diff --git a/src/ResIndex.c b/src/ResIndex.c
new file mode 100644
index 0000000..4b62b22
--- /dev/null
+++ b/src/ResIndex.c
@@ -0,0 +1,162 @@
+// ==================================================================
+// HashMap.h
+// Copyright (c) Martin Larralde, 2025
+// ==================================================================
+// Implementation of type ResIndex.
+// ==================================================================
+
+#include <stddef.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+
+#include "Atom.h"
+#include "ResIndex.h"
+
+#ifdef _MSC_VER
+#define strncasecmp _strnicmp
+#define strcasecmp _stricmp
+#endif
+
+static int ResNames_compare(const void *pa, const void *pb)
+{
+	const Atom *a = **((const Atom***)pa);
+	const Atom *b = **((const Atom***)pb);
+    int result = strncasecmp(&a->resName[0], &b->resName[0], 4);
+    if (result != 0)
+        return result;
+    return a->serial - b->serial;
+}
+
+extern ResIndex* ResIndex_create(Atom** atoms, int n)
+{
+    int i;
+    int j;
+    int k;
+    int numRes;
+    Atom*** tmp;
+    ResIndex* I;
+
+    // Allocate struct
+
+    I = calloc(1, sizeof(ResIndex));
+    if(!I) {
+        return NULL;
+    }
+
+    // Initialize fields
+    I->n = 0;
+    I->names = NULL;
+    I->offset = NULL;
+    I->atoms = NULL;
+
+    // Handle empty case
+    if(n==0) {
+        I->offset = calloc(2, sizeof(size_t));
+        I->atoms = (Atom**) calloc(1, sizeof(Atom*));
+        I->offset[0] = I->offset[1] = 0;
+        I->atoms[0] = NULL;
+        return I;
+    }
+
+    // Allocate auxilliary data to sort names
+
+    tmp = (Atom***) calloc(n, sizeof(Atom**));
+    if(!tmp) {
+        ResIndex_free(I);
+        return NULL;
+    }
+
+    // Sort residue names found in molecule
+
+    for (i = 0; i < n; i++) tmp[i] = (Atom**) &atoms[i];
+    qsort(tmp,n, sizeof(Atom**),ResNames_compare);
+
+    // Count number of distinct residue names in molecule
+
+    numRes = 1;
+    for (i = 1; i < n; i++) 
+        numRes += (strncasecmp((*tmp[i-1])->resName, (*tmp[i])->resName, 4) != 0);
+    
+    // Allocate data for residues
+
+    I->names = (char*) calloc(numRes, 4*sizeof(char));
+    I->offset = (size_t*) calloc(numRes+1, sizeof(size_t));
+    I->atoms = (Atom**) calloc(n + numRes, sizeof(Atom*));
+    if ((I->names == NULL) || (I->atoms == NULL) || (I->offset == NULL)) {
+        free(tmp);
+        ResIndex_free(I);
+        return NULL;
+    }
+
+    // Record data in index
+
+    memcpy(&I->names[0], (*tmp[0])->resName, 4*sizeof(char));
+    I->n = numRes;
+    I->offset[0] = 0;
+    I->atoms[0] = *tmp[0];
+
+    char* names = &I->names[4];
+    size_t* offset = &I->offset[1];
+
+    for (i = 1, j = 4, k = 1; i < n; i++) {
+
+        if (strncasecmp((*tmp[i-1])->resName, (*tmp[i])->resName, 4) != 0) {
+            memcpy(names, (*tmp[i])->resName, 4*sizeof(char));
+            names += 4;
+
+            I->atoms[k] = NULL;
+            k += 1;
+
+            (*offset) = k;
+            offset++;
+        }
+
+        I->atoms[k] = *tmp[i];
+        k += 1;
+    }
+
+    (*offset) = k;
+
+    free(tmp);
+    
+    return I;
+}
+
+extern int ResIndex_find(ResIndex* I, const char resName[4]) {
+    //NB: As the names have been sorted with `qsort`, we can use a binary search
+    //    instead of a full scan here (TODO!)
+    
+    size_t i;
+
+    for (i = 0; i < I->n; i++) {
+        if (strncasecmp(&I->names[4*i], resName, 4) == 0) {
+            return i;
+        }
+    }
+
+    return -1;
+}
+
+extern Atom** ResIndex_get(ResIndex* I, const char resName[4])
+{
+    int i = ResIndex_find(I, resName);
+    return ResIndex_values(I, i);
+}
+
+extern Atom** ResIndex_values(ResIndex* I, int i)
+{
+    if(i > I->n)
+        return &I->atoms[I->offset[1] - 1];
+    return &I->atoms[I->offset[i]];
+}
+
+extern void ResIndex_free(ResIndex* I)
+{
+    if(I) {
+        if (I->names) free(I->names);
+        if (I->atoms) free(I->atoms);
+        if (I->offset) free(I->offset);
+        free(I);
+    }
+}
