diff --git a/src/Join.c b/src/Join.c
index 52b491c..75443f2 100644
--- a/src/Join.c
+++ b/src/Join.c
@@ -6,139 +6,124 @@
 // ==================================================================
 
 #include "Join.h"
+#include "Box.h"
+#include "Annulus.h"
+
+#include <assert.h>
+#include <math.h>
 #include <stdlib.h>
 #include <string.h>
 
 // ==================================================================
-// type Join
-// ==================================================================
-// count				The number of regions in the join
-// R[k]					The kth region in the join
-// ==================================================================
-
-typedef struct _Join Join;
-
-struct _Join
-{
-	int count;
-	Region *R[0];
-};
-
-// ==================================================================
-// The oracles
+// Oracles for type Join
 // ==================================================================
 
-static int Join_oro(Region *R,double *min,double *max,int dim)
+int Join_oro(Region *R,double *min,double *max) 
 {
 	Join *J=(Join*)&R[1];
-	int k;
-
-	for(k=0; k<J->count; k++)
-	{
-		if(J->R[k]->intersectionQ(J->R[k],min,max,dim))
-		{
-			return 1;
-		}
-	}
-
-	return 0;
+	return _Join_oro(J,min,max);
 }
 
-static int Join_iro(Region *R,double *min,double *max,int dim)
+int Join_iro(Region *R,double *min,double *max) 
 {
 	Join *J=(Join*)&R[1];
-	int k;
-
-	for(k=0; k<J->count; k++)
-	{
-		if(!(J->R[k]->intersectionQ(J->R[k],min,max,dim)))
-		{
-			return 0;
-		}
-	}
-
-	return 1;
+	return _Join_iro(J,min,max);
 }
 
-static int Join_opo(Region *R,double *x,int dim)
+int Join_opo(Region *R,double *x)
 {
 	Join *J=(Join*)&R[1];
-	int k;
-
-	for(k=0; k<J->count; k++)
-	{
-		if(J->R[k]->inclusionQ(J->R[k],x,dim))
-		{
-			return 1;
-		}
-	}
-
-	return 0;
+	return _Join_opo(J,x);
 }
 
-static int Join_ipo(Region *R,double *x,int dim)
+int Join_ipo(Region *R,double *x)
 {
 	Join *J=(Join*)&R[1];
-	int k;
-
-	for(k=0; k<J->count; k++)
-	{
-		if(!(J->R[k]->inclusionQ(J->R[k],x,dim)))
-		{
-			return 0;
-		}
-	}
-
-	return 1;
+	return _Join_ipo(J,x);
 }
 
 // ==================================================================
 // Construction and destruction
 // ==================================================================
 
-Region *Join_create(Region **S,int count,JoinType type)
+Join *Join_allocate(int count,JoinType type)
 {
-	Region *R;
 	Join *J;
 	int rq;
 
-	rq = sizeof(Region)+sizeof(Join)+sizeof(Region*)*count;
-	R = (Region*)calloc(1,rq);
-	J = (Join*)&R[1];
-	memcpy(J->R,S,sizeof(Region*)*count);
+	rq = sizeof(Join)+sizeof(Annulus*)*count;
+	J = (Join*)malloc(rq);
+	if(!J) return NULL;
 
-	R->free=Join_free;
 	J->count=count;
+	J->type=type;
+	for(int i=0;i<count;i++) J->R[i]=NULL;
+
+	return J;
+}
+
+Join *Join_create(const Annulus **S,int count,JoinType type)
+{
+	Join *J = Join_allocate(count,type);
+	if(!J) return NULL;
+	memcpy(J->R,S,sizeof(Annulus*)*count);
+
+	return J;
+}
 
-	if(type==innerJoin)
+#ifndef Jess_min
+#define Jess_min(x,y) (x<y ? x:y)
+#endif
+
+#ifndef Jess_max
+#define Jess_max(x,y) (x>y ? x:y)
+#endif
+
+void Join_computeBox(const Join* J, Box* B)
+{
+	int i;
+	int r;
+
+	assert(J);
+	assert(B);
+	
+	if(J->count == 0)
 	{
-		R->intersectionQ = Join_iro;
-		R->inclusionQ = Join_ipo;
+		for(i=0;i<BOX_DIM;i++)
+		{
+			B->min[i] = 0.0;
+			B->max[i] = 0.0;
+		}
 	}
-	else // if type==outerJoin
+	else
 	{
-		R->intersectionQ = Join_oro;
-		R->inclusionQ = Join_opo;
+		for(i=0;i<BOX_DIM;i++)
+		{
+			B->min[i] = -INFINITY;
+			B->max[i] =  INFINITY;
+			for(r=0;r<J->count;r++)
+			{
+				B->min[i] = Jess_max(B->min[i], J->R[r]->minBox[i]);
+				B->max[i] = Jess_min(B->max[i], J->R[r]->maxBox[i]);
+			}
+		}
 	}
-
-	return R;
 }
 
-void Join_free(Region *R)
+#undef Jess_min
+#undef Jess_max
+
+void Join_free(Join *J)
 {
-	Join *J;
 	int k;
 
-	if(R)
+	if(J)
 	{
-		J = (Join*)&R[1];
-
 		for(k=0; k<J->count; k++)
 		{
-			if(J->R[k]) J->R[k]->free(J->R[k]);
+			if(J->R[k]) Annulus_free(J->R[k]);
 		}
-
-		free(R);
+		free(J);
 	}
 }
 
