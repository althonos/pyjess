diff --git a/src/Annulus.h b/src/Annulus.h
index 9bb1060..17cfc80 100644
--- a/src/Annulus.h
+++ b/src/Annulus.h
@@ -9,16 +9,100 @@
 #define ANNULUS_H
 
 #include "Region.h"
+#include <math.h>
+
+#define ANNULUS_DIM 3
+
+// ==================================================================
+// type Annulus
+// ==================================================================
+// centre				The center of the annulus
+// min,max				Limits of the radii
+// dim					The dimension of the space
+// a,b					Inner and outer radii
+// ==================================================================
+
+struct _Annulus
+{
+	double centre[ANNULUS_DIM];
+	double minBox[ANNULUS_DIM];
+	double maxBox[ANNULUS_DIM];
+	double min;
+	double max;
+};
+
+typedef struct _Annulus Annulus;
 
 // ==================================================================
 // Methods for Annulus manipulation
 // ==================================================================
-// create(u,a,b,d)		Make region {x in R^d : a <= |x-u| <= b }.
+// create(u,a,b)		Make region {x in R^3 : a <= |x-u| <= b }.
 // free(A)				Free the region given (or use R->free)
 // ==================================================================
 
-extern Region *Annulus_create(double*,double,double,int);
-extern void Annulus_free(Region*);
+extern Annulus *Annulus_create(const double*,double,double);
+extern Annulus *Annulus_reuse(Annulus*,const double*,double,double);
+extern void Annulus_free(Annulus*);
+
+// ==================================================================
+// Oracles
+// ==================================================================
+
+int Annulus_po(Region *vA, double *x);
+int Annulus_ro(Region *vA, double *minBox, double *maxBox);
+
+static inline int _Annulus_po(const Annulus* A, const double* x)
+{
+	double tmp,sum;
+	int i;
+
+	// Does x lie within annulus A?
+
+	for(sum=0.0,i=0; i<ANNULUS_DIM; i++)
+	{
+		tmp = A->centre[i]-x[i];
+		sum += tmp*tmp;
+	}
+
+	return sum<A->min || sum>A->max ? 0:1;
+}
+
+#ifndef Jess_min
+#define Jess_min(x,y) (x<y ? x:y)
+#endif
+
+#ifndef Jess_max
+#define Jess_max(x,y) (x>y ? x:y)
+#endif
+
+static inline int _Annulus_ro(const Annulus *A, const double* restrict minBox, const double* restrict maxBox)
+{
+	int i;
+	double t1,t2;
+	double minSum, maxSum;
+
+	// Does the box region [minBox,maxBox] intersect the annulus A?
+
+	minSum=0.0;
+	maxSum=0.0;
+	for(i=0; i<ANNULUS_DIM; i++)
+	{
+		t1 = A->centre[i]-minBox[i];
+		t2 = A->centre[i]-maxBox[i];
+		t1 *= t1;
+		t2 *= t2;
+		if(minBox[i]>A->centre[i] || maxBox[i]<A->centre[i])
+		{
+			minSum += Jess_min(t1,t2);
+		}
+		maxSum += Jess_max(t1,t2);
+	}
+	return minSum>A->max || maxSum<A->min ? 0:1;
+
+}
+
+#undef Jess_min
+#undef Jess_max
 
 // ==================================================================
 
