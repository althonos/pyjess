diff --git a/src/Annulus.c b/src/Annulus.c
index b292fda..2587096 100644
--- a/src/Annulus.c
+++ b/src/Annulus.c
@@ -10,103 +10,38 @@
 #include <string.h>
 #include <math.h>
 
-// ==================================================================
-// Local "functions"
-// ==================================================================
-
-#define min(x,y) (x<y ? x:y)
-#define max(x,y) (x>y ? x:y)
-
-// ==================================================================
-// type Annulus
-// ==================================================================
-// centre				The center of the annulus
-// min,max				Limits of the radii
-// dim					The dimension of the space
-// ==================================================================
-
-typedef struct _Annulus
-{
-	double *centre;
-	double min;
-	double max;
-	int dim;
-}
-Annulus;
-
 // ==================================================================
 // Oracles for type Annulus
 // ==================================================================
 
-static int Annulus_po(Region *vA, double *x, int d)
+int Annulus_po(Region *vA, double *x)
 {
 	Annulus *A=(Annulus*)&vA[1];
-	double tmp,sum;
-	int i;
-
-	// Does x lie within annulus A?
-
-	if(A->dim!=d) return 0;
-
-	for(sum=0.0,i=0; i<d; i++)
-	{
-		tmp = A->centre[i]-x[i];
-		sum += tmp*tmp;
-	}
-
-	return sum<A->min || sum>A->max ? 0:1;
+	return _Annulus_po(A, x);
 }
 
-static int Annulus_ro(Region *vA, double *minBox, double *maxBox, int d)
+int Annulus_ro(Region *vA, double *minBox, double *maxBox)
 {
 	Annulus *A=(Annulus*)&vA[1];
-	double minSum;
-	double maxSum;
- 	double t1,t2;
-	double t3,t4;
-	int i;
-
-	if(d!=A->dim) return 0;
-
-	// Does the box region [minBox,maxBox] intersect the annulus A?
-
-	minSum=0.0;
-	maxSum=0.0;
-	for(i=0; i<d; i++)
-	{
-		t1 = A->centre[i]-minBox[i];
-		t2 = A->centre[i]-maxBox[i];
-		t1 *= t1;
-		t2 *= t2;
-
-		if(minBox[i]>A->centre[i] || maxBox[i]<A->centre[i])
-		{
-			minSum += min(t1,t2);
-		}
-
-		maxSum += max(t1,t2);
-	}
-
-	return minSum>A->max || maxSum<A->min ? 0:1;
+	return _Annulus_ro(A, minBox, maxBox);
 }
 
 // ==================================================================
 // Methods of for regions of type Annulus
 // ==================================================================
 
-Region *Annulus_create(double *u, double a, double b, int d)
+Annulus *Annulus_create(const double *u, double a, double b)
 {
 	Annulus *A;
-	Region *R;
-	int rq;
+	A = (Annulus*)malloc(sizeof(Annulus));
+	return Annulus_reuse(A,u,a,b);
+}
+
+Annulus *Annulus_reuse(Annulus *A, const double *u, double a, double b)
+{
 	double tmp;
 
-	rq = sizeof(Region)+sizeof(Annulus)+d*sizeof(double);
-	R = (Region*)calloc(1,rq);
-	A = (Annulus*)&R[1];
-	R->intersectionQ=Annulus_ro;
-	R->inclusionQ=Annulus_po;
-	R->free=Annulus_free;
+	if(!A) return Annulus_create(u,a,b);
 
 	if(b<a)
 	{
@@ -118,18 +53,22 @@ Region *Annulus_create(double *u, double a, double b, int d)
 	if(a<0.0) a=0.0;
 	if(b<0.0) b=0.0;
 
-	A->centre=(double*)&A[1];
-	memcpy(A->centre,u,sizeof(double)*d);
+	memcpy(A->centre,u,sizeof(double)*ANNULUS_DIM);
 	A->min=a*a;
 	A->max=b*b;
-	A->dim=d;
 
-	return R;
+	for(int i=0; i<ANNULUS_DIM;i++)
+	{
+		A->minBox[i] = A->centre[i] - b;
+		A->maxBox[i] = A->centre[i] + b;
+	}
+
+	return A;
 }
 
-void Annulus_free(Region *R)
+void Annulus_free(Annulus *A)
 {
-	if(R) free(R);
+	if(A) free(A);
 }
 
 // ==================================================================
