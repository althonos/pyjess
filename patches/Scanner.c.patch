diff --git a/src/Scanner.c b/src/Scanner.c
index 19a35a7..fe99f2a 100644
--- a/src/Scanner.c
+++ b/src/Scanner.c
@@ -5,41 +5,35 @@
 // Implementation of type Scanner (the main Jess query object).
 // ==================================================================
 
+#include <stdlib.h>
+#include <stdbool.h>
+#include <string.h>
+
 #include "Scanner.h"
 #include "KdTree.h"
 #include "Region.h"
 #include "Annulus.h"
 #include "Join.h"
-#include <stdlib.h>
-#include <string.h>
+#include "CandidateSet.h"
 
 // ==================================================================
-// Local type CandidateSet
-// ==================================================================
-// count				Number of atoms in the set
-// atom[k]				Points to ATOM record for kth candidate
-// coord[k]				Points to coordinates for kth candidate
-// ==================================================================
-
-typedef struct _CandidateSet CandidateSet;
+// type ScannerData
+//===================================================================
 
-struct _CandidateSet
+struct _ScannerData
 {
-	int count;
-	Atom **atom;
-	double **coord;
+	size_t count;
+	size_t capacity;
+	CandidateSet** candidates;
+	int* index;
+	Atom** atom;
+	Join** regions;
+	bool *active;
+	KdTree **trees;
+	KdTreeQuery **queries;
+	double* weights;
 };
 
-// ==================================================================
-// Declaration of methods of local type CandidateSet
-// ==================================================================
-// create(M,T,k)		Create from molecule M, atom k of T
-// free(S)				Free candidate set
-// ==================================================================
-
-static CandidateSet *CandidateSet_create(Molecule*,Template*,int);
-static void CandidateSet_free(CandidateSet*);
-
 // ==================================================================
 // type Scanner
 //===================================================================
@@ -63,9 +57,11 @@ struct _Scanner
 	CandidateSet **set;
 	KdTree **tree;
 	KdTreeQuery **query;
+	bool *active;
 	int *index;
 	Atom **atom;
-	Region **region;
+	Join **regions;
+	double *weights;
 	int count;
 	double threshold;
 	double max_total_threshold;
@@ -75,19 +71,31 @@ struct _Scanner
 // Methods of type Scanner
 // ==================================================================
 
-Scanner *Scanner_create(Molecule *M, Template *T,double r, double s)
+Scanner *Scanner_create(Molecule *M, Template *T, ScannerData* D, double r, double s)
+{
+	Scanner* S;
+	S=(Scanner*)calloc(1,sizeof(Scanner));
+	if(!S) return NULL;
+	return Scanner_reuse(S,M,T,D,r,s);
+}
+
+Scanner *Scanner_reuse(Scanner *S, Molecule *M, Template *T, ScannerData* D, double r, double s)
 {
-	Scanner *S;
 	int k,n=T->count(T);
 	int m;
 
-	S=(Scanner*)calloc(1,sizeof(Scanner));
-	S->set=(CandidateSet**)calloc(n,sizeof(CandidateSet*));
-	S->tree=(KdTree**)calloc(n,sizeof(KdTree*));
-	S->query=(KdTreeQuery**)calloc(n,sizeof(KdTreeQuery*));
-	S->index=(int*)calloc(n,sizeof(int));
-	S->atom=(Atom**)calloc(n,sizeof(Atom*));
-	S->region=(Region**)calloc(n,sizeof(Region*));
+	if(!D) return NULL;
+	if(!S) return Scanner_create(M,T,D,r,s);
+	if(ScannerData_resize(D,n)!=0) return NULL;
+
+	S->set=D->candidates;
+	S->tree=D->trees;
+	S->query=D->queries;
+	S->index=D->index;
+	S->atom=D->atom;
+	S->regions=D->regions;
+	S->active=D->active;
+	S->weights=D->weights;
 
 	S->template=T;
 	S->threshold=r;
@@ -97,15 +105,23 @@ Scanner *Scanner_create(Molecule *M, Template *T,double r, double s)
 	for(k=0; k<n; k++)
 	{
 		S->index[k]=-1;
-		S->set[k]=CandidateSet_create(M,T,k);
+		S->active[k]=false;
+		S->weights[k]=S->template->distWeight(S->template, k);
 
+		T->candidates(T,M,k, &S->set[k]);
 		if(S->set[k]->count==0)
 		{
 			Scanner_free(S);
 			return NULL;
 		}
 
-		S->tree[k]=KdTree_create(S->set[k]->coord,S->set[k]->count,3);
+		S->tree[k]=KdTree_reuse(S->tree[k],S->set[k]->coord,S->set[k]->count,3);
+		if(!S->tree[k])
+		{
+			Scanner_free(S);
+			return NULL;
+		}
+
 	}
 
 	if(S->count>0 && S->set[0]->count>0)
@@ -119,26 +135,8 @@ Scanner *Scanner_create(Molecule *M, Template *T,double r, double s)
 
 void Scanner_free(Scanner *S)
 {
-	int k,n;
-
 	if(S)
 	{
-		n = S->template->count(S->template);
-
-		for(k=0; k<n; k++)
-		{
-			if(S->set && S->set[k]) CandidateSet_free(S->set[k]);
-			if(S->tree && S->tree[k]) KdTree_free(S->tree[k]);
-			if(S->query && S->query[k]) KdTreeQuery_free(S->query[k]);
-		}
-
-		if(S->set) free(S->set);
-		if(S->query) free(S->query);
-		if(S->tree) free(S->tree);
-		if(S->atom) free(S->atom);
-		if(S->index) free(S->index);
-		if(S->region) free(S->region);
-
 		free(S);
 	}
 }
@@ -147,8 +145,6 @@ Atom **Scanner_next(Scanner *S, int ignore_chain)
 {
 	int j,k;
 	double min,max;
-	Region *J;
-
 	double dynamic_threshold = S->threshold;
 
 	k=S->count-1;
@@ -186,7 +182,7 @@ Atom **Scanner_next(Scanner *S, int ignore_chain)
 		// So k>0. If there is an active query for this
 		// set then query it now...
 
-		if(S->query[k])
+		if(S->active[k])
 		{
 			S->index[k]=KdTreeQuery_next(S->query[k]);
 			if(S->index[k]<0)
@@ -194,8 +190,7 @@ Atom **Scanner_next(Scanner *S, int ignore_chain)
 				// The query ended. So we need to destroy
 				// this query, then drop down a level...
 
-				KdTreeQuery_free(S->query[k]);
-				S->query[k]=NULL;
+				S->active[k]=false;
 				S->atom[k]=NULL;
 				k--;
 			}
@@ -228,12 +223,11 @@ Atom **Scanner_next(Scanner *S, int ignore_chain)
 		// So, there is an active query result at k-1 and
 		// no active query at k; create a new query at
 		// index k and try again (with the same k)
-
 		for(j=0; j<k; j++)
 		{
 			S->template->range(S->template,j,k,&min,&max);
 
-			dynamic_threshold = S->threshold + S->template->distWeight(S->template, j) + S->template->distWeight(S->template, k);
+			dynamic_threshold = S->threshold + S->weights[j] + S->weights[k];
 			// Limit threshold to a hard cutoff so execution does not suffer
 			if(dynamic_threshold > S->max_total_threshold){
 				dynamic_threshold = S->max_total_threshold;
@@ -242,11 +236,12 @@ Atom **Scanner_next(Scanner *S, int ignore_chain)
 			max += dynamic_threshold;
 			if(min<0.5) min=0.5;
 
-			S->region[j]=Annulus_create(S->atom[j]->x,min,max,3);
+			S->regions[k]->R[j]=Annulus_reuse(S->regions[k]->R[j],S->atom[j]->x,min,max,3);
 		}
 
-		J = Join_create(S->region,k,innerJoin);
-		S->query[k]=KdTree_query(S->tree[k],J);
+		S->active[k]=true;
+		S->query[k]=KdTreeQuery_reuse(S->query[k],S->tree[k],S->regions[k]);
+		if(!S->query[k]) return NULL;
 	}
 
 	// If k<0 there is no more!
@@ -259,49 +254,103 @@ Atom **Scanner_next(Scanner *S, int ignore_chain)
 }
 
 // ==================================================================
-// Methods of local type CandidateSet
+// Methods of type ScannerData
 // ==================================================================
 
-static CandidateSet *CandidateSet_create(Molecule *M, Template *T, int k)
+ScannerData *ScannerData_create()
 {
-	CandidateSet *S;
-	Atom *A;
-	int n = Molecule_count(M);
-	int m;
-
-	S = (CandidateSet*)calloc(1,sizeof(CandidateSet));
-	S->atom=(Atom**)calloc(n,sizeof(Atom*));
+	ScannerData* D = malloc(sizeof(ScannerData));
+	if(!D) return NULL;
+	D->count=0;
+	D->capacity=0;
+	D->candidates=NULL;
+	D->index=NULL;
+	D->atom=NULL;
+	D->regions=NULL;
+	D->active=NULL;
+	D->queries=NULL;
+	D->trees=NULL;
+	D->weights=NULL;
+	return D;
+}
 
-	for(m=0; m<n; m++)
+void ScannerData_free(ScannerData* D)
+{
+	if(D)
 	{
-		A = (Atom*)Molecule_atom(M,m);
-		if(T->match(T,k,A))
+		if(D->candidates) 
 		{
-			S->atom[S->count]=A;
-			S->count++;
+			for(int i=0;i<D->capacity;i++) CandidateSet_free(D->candidates[i]);
+			free(D->candidates);
 		}
+		if(D->regions)
+		{
+			for(int i=0;i<D->capacity;i++) Join_free(D->regions[i]);
+			free(D->regions);
+		}
+		if(D->queries)
+		{
+			for(int i=0;i<D->capacity;i++) KdTreeQuery_free(D->queries[i]);
+			free(D->queries);
+		}
+		if(D->trees)
+		{
+			for(int i=0;i<D->capacity;i++) KdTree_free(D->trees[i]);
+			free(D->trees);
+		}
+		if(D->index) free(D->index);
+		if(D->atom) free(D->atom);
+		if(D->active) free(D->active);
+		if(D->weights) free(D->weights);
+		free(D);
 	}
-
-	S->atom=(Atom**)realloc(S->atom,sizeof(Atom*)*S->count);
-	S->coord=(double**)calloc(S->count,sizeof(double*));
-
-	for(m=0; m<S->count; m++)
-	{
-		S->coord[m]=S->atom[m]->x;
-	}
-
-	return S;
 }
 
-static void CandidateSet_free(CandidateSet *S)
+int ScannerData_resize(ScannerData* D, int n)
 {
-	if(S)
+	if(D->capacity<n)
 	{
-		if(S->atom) free(S->atom);
-		if(S->coord) free(S->coord);
-		free(S);
+		D->candidates=(CandidateSet**)realloc(D->candidates,n*sizeof(CandidateSet*));
+		if(!D->candidates) return -1;
+		for(int i=D->capacity;i<n;i++)
+		{
+			D->candidates[i]=CandidateSet_create();
+			if(!D->candidates[i]) return -1;
+		}
+
+		D->regions=(Join**)realloc(D->regions,n*sizeof(Join*));
+		if(!D->regions) return -1;
+		for(int i=D->capacity;i<n;i++)
+		{
+			D->regions[i]=Join_allocate(i,innerJoin);
+			if(!D->regions[i]) return -1;
+		}
+
+		D->trees=(KdTree**)realloc(D->trees,n*sizeof(KdTree*));
+		if(!D->trees) return -1;
+		for(int i=D->capacity;i<n;i++) D->trees[i]=NULL;
+
+		D->queries=(KdTreeQuery**)realloc(D->queries,n*sizeof(KdTreeQuery*));
+		if(!D->queries) return -1;
+		for(int i=D->capacity;i<n;i++) D->queries[i]=NULL;
+
+		D->index=(int*)realloc(D->index,n*sizeof(int));
+		if(!D->index) return -1;
+
+		D->atom=(Atom**)realloc(D->atom,n*sizeof(Atom*));
+		if(!D->atom) return -1;
+
+		D->active=(bool*)realloc(D->active,n*sizeof(bool));
+		if(!D->active) return -1;
+
+		D->weights=(double*)realloc(D->weights,n*sizeof(double));
+		if(!D->weights) return -1;
+
+		D->capacity=n;
 	}
+
+	D->count=n;
+	return 0;
 }
 
 // ==================================================================
-
