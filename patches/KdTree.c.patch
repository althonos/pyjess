diff --git a/src/KdTree.c b/src/KdTree.c
index 5d8d783..e085187 100644
--- a/src/KdTree.c
+++ b/src/KdTree.c
@@ -6,9 +6,16 @@
 // ==================================================================
 
 #include "KdTree.h"
+#include "qselect.h"
+
+#include <assert.h>
 #include <stdlib.h>
 #include <string.h>
 #include <stdio.h>
+#include <stdint.h>
+
+#define NO_NODE	SIZE_MAX
+#define DIM 3
 
 // ==================================================================
 // Forward declarations of local types
@@ -16,6 +23,7 @@
 // KdTreeNode			One node of a KdTree
 // ==================================================================
 
+typedef size_t index_t; 
 typedef struct _KdTreeNode KdTreeNode;
 
 // ==================================================================
@@ -30,12 +38,12 @@ typedef struct _KdTreeNode KdTreeNode;
 
 struct _KdTreeNode
 {
+	index_t left;
+	index_t right;
+	double min[DIM];
+	double max[DIM];
 	int type;
 	int index;
-	KdTreeNode *left;
-	KdTreeNode *right;
-	double *min;
-	double *max;
 	int depth;
 };
 
@@ -46,20 +54,25 @@ struct _KdTreeNode
 // free(N)				Frees a node and all its descendants
 // ==================================================================
 
-static KdTreeNode *KdTreeNode_create(int*,int,int,double**,int);
-static void KdTreeNode_free(KdTreeNode*);
+static index_t KdTreeNode_create(KdTree*,int*,int,int,const double**);
+// static void KdTreeNode_free(KdTreeNode*);
 
 // ==================================================================
 // type KdTree
 // ==================================================================
 // root					The root of the tree
 // dim					Dimension of the points
+// node					The nodes stored in an array
+// capacity				The capacity of the node array
+// count				The number of element in the node array
 // ==================================================================
 
 struct _KdTree
 {
-	KdTreeNode *root;
-	int dim;
+	KdTreeNode *nodes;
+	size_t count;
+	size_t capacity;
+	index_t root;
 };
 
 // ==================================================================
@@ -73,10 +86,12 @@ struct _KdTree
 
 struct _KdTreeQuery
 {
-	KdTree *tree;
-	Region *region;
+	const KdTree* tree;
+	const Join* region;
+	Box box;
 	int count;
-	KdTreeNode *stack[0];
+	int maxdepth;
+	index_t stack[0];
 };
 
 
@@ -87,63 +102,84 @@ struct _KdTreeQuery
 // data,index			Static globals (see KdTreeNode_create)
 // ==================================================================
 
-static int KdTree_compare(const void*,const void*);
+static int KdTree_compare(const void*, const void*);
+static int KdTree_compare_r(const void*, const void*, void*);
+
+#ifdef HAVE_THREADLOCALSTORAGE
+static __thread double **KdTree_data;
+static __thread int KdTree_index;
+#else
 static double **KdTree_data;
 static int KdTree_index;
+#endif
+
+struct _KdTreeCompareData
+{
+      const double** data;
+      int index;
+};
 
 // ==================================================================
-// Local functions
+// Public methods of type KdTree
 // ==================================================================
 
-static double dmin(double x, double y)
+KdTree *KdTree_create(const double **u, int n)
 {
-	return x<y ? x:y;
-}
+	KdTree *K;
+	int i,j;
+	int *tmp;
 
-static double dmax(double x, double y)
-{
-	return x>y ? x:y;
-}
+	assert(!(n<1 || !u));
 
-static int imin(int x, int y)
-{
-	return x<y ? x:y;
-}
+	K = (KdTree*)malloc(sizeof(KdTree));
+	if(!K) return NULL;
 
-static int imax(int x, int y)
-{
-	return x>y ? x:y;
-}
+	K->root=NO_NODE;
+	K->nodes=NULL;
+	K->capacity=0;
+	K->count=0;
 
-// ==================================================================
-// Public methods of type KdTree
-// ==================================================================
+	return KdTree_reuse(K,u,n);
+}
 
-KdTree *KdTree_create(double **u, int n, int d)
+KdTree *KdTree_reuse(KdTree *K, const double **u, int n)
 {
-	KdTree *K;
 	int i,j;
 	int *tmp;
 
-	if(n<1 || d<1 || !u) return NULL;
+	if(!K) {
+		K = (KdTree*)malloc(sizeof(KdTree));
+		if(!K) return NULL;
+		K->nodes=NULL;
+		K->capacity=0;
+	}
 
-	// 1. Create memory for the object.
+	if(n<1 || !u) {
+		KdTree_free(K);
+		return NULL;
+	}
 
-	K = (KdTree*)calloc(1,sizeof(KdTree));
-	K->dim=d;
+	K->count=0;
+	K->root=NO_NODE;
 
 	// 3a. Create a temporary array to hold indices
 
-	tmp = (int*)calloc(n,sizeof(int));
+	tmp = (int*)malloc(n*sizeof(int));
 	for(i=0; i<n; i++) tmp[i]=i;
 
 	// 3b. Create the tree recursively. This takes time
 	// of order at most n.log(n)^2, assuming that qsort
 	// always manages n.log(n) and d is constant.
 
-	K->root = KdTreeNode_create(tmp,n,0,u,d);
+	K->root = KdTreeNode_create(K,tmp,n,0,u);
 	free(tmp);
 
+	if(K->root == NO_NODE) 
+	{
+		KdTree_free(K);
+		return NULL;
+	}
+
 	// 4. Return the result!
 
 	return K;
@@ -155,37 +191,57 @@ void KdTree_free(KdTree *K)
 
 	if(K)
 	{
-		KdTreeNode_free(K->root);
+		if(K->nodes) free(K->nodes);
 		free(K);
 	}
 }
 
-KdTreeQuery *KdTree_query(KdTree *K, Region *R)
+KdTreeQuery *KdTree_query(KdTree *K, Join *J)
+{
+	return KdTreeQuery_reuse(NULL,K,J);
+}
+
+// ==================================================================
+// Methods of type KdTreeQuery
+// ==================================================================
+
+KdTreeQuery *KdTreeQuery_reuse(KdTreeQuery *Q, KdTree *K, Join *J)
 {
-	KdTreeQuery *Q;
 	int rq;
 
-	rq = sizeof(KdTreeQuery)+K->root->depth*sizeof(KdTreeNode*);
+	assert(K);
+	assert(J);
+	assert(J->type == innerJoin);
+
+	if(!(Q) || (Q->maxdepth < K->nodes[K->root].depth))
+	{
+		rq = sizeof(KdTreeQuery)+K->nodes[K->root].depth*sizeof(index_t);
+		Q=(KdTreeQuery*)realloc(Q,rq);
+		if(!Q) return NULL;
+		Q->maxdepth=K->nodes[K->root].depth;
+	}
 
-	Q = (KdTreeQuery*)calloc(1,rq);
 	Q->tree=K;
-	Q->region=R;
+	Q->region=J;
 	Q->count=1;
 	Q->stack[0]=K->root;
 
+	// NB: compute a bounding box around the `Join` so we can use
+	//	   the bounding box to compute intersections in `KdTreeQuery_next`
+	//	   instead of computing the individual `Annulus` intersections.
+
+	Join_computeBox(Q->region,&Q->box);
+
 	return Q;
 }
 
-// ==================================================================
-// Methods of type KdTreeQuery
-// ==================================================================
-
 int KdTreeQuery_next(KdTreeQuery *Q)
 {
-	KdTreeNode *N;
-	Region *R = Q->region;
-	KdTreeNode **stack=&(Q->stack[0]);
-	int dim = Q->tree->dim;
+	const KdTreeNode* N;
+	const Join* J = Q->region;
+	const Box* B = &Q->box;
+	JoinType jointype = J->type;
+	index_t *stack=&(Q->stack[0]);
 	int *count = &(Q->count);
 
 	// Until the stack is empty (or we return inside
@@ -195,7 +251,7 @@ int KdTreeQuery_next(KdTreeQuery *Q)
 	{
 		// Pull the top node off the stack.
 
-		N = stack[--(*count)];
+		N = &Q->tree->nodes[stack[--(*count)]];
 
 		// If the node is a leaf we simply test it and
 		// remove it from the stack. If the point is in
@@ -204,7 +260,7 @@ int KdTreeQuery_next(KdTreeQuery *Q)
 
 		if(N->type<0)
 		{
-			if(R->inclusionQ(R,N->min,dim))
+			if(_Join_po(J,N->min))
 			{
 				return N->index;
 			}
@@ -219,9 +275,13 @@ int KdTreeQuery_next(KdTreeQuery *Q)
 		// the node's region then we can remove it
 		// and continue with the rest of the stack.
 
-		if(!R->intersectionQ(R,N->min,N->max,dim))
+		if(jointype==innerJoin)
 		{
-			continue;
+			if(!_Box_ro(B,N->min,N->max)) continue;
+		}
+		else
+		{
+			if(!_Join_ro(J,N->min,N->max)) continue;
 		}
 
 		// The query region *does* intersect the node's
@@ -239,7 +299,6 @@ void KdTreeQuery_free(KdTreeQuery *Q)
 {
 	if(Q)
 	{
-		if(Q->region) Q->region->free(Q->region);
 		free(Q);
 	}
 }
@@ -258,26 +317,53 @@ static int KdTree_compare(const void *pa, const void *pb)
 	return c<d ? -1 : c>d ? 1 : 0;
 }
 
+static int KdTree_compare_r(const void* pa, const void* pb, void* data)
+{
+	struct _KdTreeCompareData _data  = *((struct _KdTreeCompareData*) data);
+	const int a = *((const int*)pa);
+	const int b = *((const int*)pb);
+	double c = _data.data[a][_data.index];
+	double d = _data.data[b][_data.index];
+
+	return c<d ? -1 : c>d ? 1 : 0;
+}
+
 // ==================================================================
 // Methods of local type KdTreeNode
 // ==================================================================
 
-static KdTreeNode *KdTreeNode_create(int *idx,int n,int type,double **u,int dim)
+#ifndef Jess_min
+#define Jess_min(x,y) (x<y ? x:y)
+#endif
+
+#ifndef Jess_max
+#define Jess_max(x,y) (x>y ? x:y)
+#endif
+
+static index_t KdTreeNode_create(KdTree *K, int *idx, int n, int type,const double **u)
 {
 	KdTreeNode *N;
 	int split;
 	int i,rq;
+	index_t k, left, right;
 
 	// 1. The really easy case. If n is 0 do nothing!
 
-	if(n<=0) return NULL;
+	if(n<=0) return NO_NODE;
 
 	// 1.5. We'll need to create a node in all other cases.
 
-	rq = sizeof(KdTreeNode)+dim*2*sizeof(double);
-	N = (KdTreeNode*)calloc(1,rq);
-	N->min=(double*)&N[1];
-	N->max=&N->min[dim];
+	if(K->count>=K->capacity) {
+		K->capacity = (K->capacity) ? K->capacity + (K->capacity >> 3) + 6 : 64;
+		K->nodes = realloc(K->nodes, K->capacity*sizeof(KdTreeNode));
+		if(!K->nodes) return NO_NODE;
+	}
+
+	k=K->count;
+	N=&K->nodes[k];
+	K->count++;
+	N->left = NO_NODE;
+	N->right = NO_NODE;
 
 	// 2. The easy case. If n is 1, create a leaf.
 
@@ -286,61 +372,58 @@ static KdTreeNode *KdTreeNode_create(int *idx,int n,int type,double **u,int dim)
 		N->type=-1;
 		N->index=idx[0];
 		N->depth=1;
-		memcpy(N->min,u[idx[0]],sizeof(double)*dim);
-		memcpy(N->max,u[idx[0]],sizeof(double)*dim);
-
-		return N;
+		N->left = NO_NODE;
+		N->right = NO_NODE;
+		memcpy(N->min,u[idx[0]],sizeof(double)*DIM);
+		memcpy(N->max,u[idx[0]],sizeof(double)*DIM);
+		return k;
 	}
-
+ 
 	// 2.5. Now we need to order the indices by coordinate
-	// numbered type. THIS IS NOT THREAD-SAFE. This kludge
-	// is used because it's not possible to pass extra
-	// parameters to qsort.
+	// numbered type.
 
-	KdTree_data=u;
-	KdTree_index=type;
-	qsort(idx,n,sizeof(int),KdTree_compare);
+	struct _KdTreeCompareData _data = { u, type };
+	split = qselect_r(idx, n, sizeof(int), n/2, KdTree_compare_r, &_data);
 
 	// 3. The recursive case. Find [n/2] and split the array into
 	// two pieces. Create a node whose splitting value is the median.
 	// But make sure that if there are several entries with the same
 	// coordinate that we take the right-most.
 
-	split = n/2;
-	N->index=idx[split-1];
-	while(split<n-1 && u[split+1][type]==u[split][type]) split++;
 	N->type=type;
+	N->index=idx[split-1];
 
 	// Now create the left and right branches of the node.
 
-	type = (type+1)%dim;
-	N->left = KdTreeNode_create(idx,split,type,u,dim);
-	N->right = KdTreeNode_create(&idx[split],n-split,type,u,dim);
+	type = (type+1)%DIM;
+	left = KdTreeNode_create(K, idx,split,type,u);
+	right = KdTreeNode_create(K, &idx[split],n-split,type,u);
+	if((left==NO_NODE) || (right==NO_NODE)) return NO_NODE;
 
-	// Compute max,min and depth...
+	// DANGER: we need to update the pointer `N` because the memory for
+	//		   storing nodes may have been reallocated in the recursive
+	// 		   `KdTreeNode_create` calls. Then it's safe again to access
+	//		   and update it.
+
+	N=&K->nodes[k];
+	N->left=left;
+	N->right=right;
 
-	N->depth = imax(N->left->depth,N->right->depth)+1;
+	// Compute max,min and depth...
+	N->depth=Jess_max(K->nodes[left].depth,K->nodes[right].depth)+1;
 
-	for(i=0; i<dim; i++)
+	for(i=0; i<DIM; i++)
 	{
-		N->min[i]=dmin(N->left->min[i],N->right->min[i]);
-		N->max[i]=dmax(N->left->max[i],N->right->max[i]);
+		N->min[i]=Jess_min(K->nodes[left].min[i],K->nodes[right].min[i]);
+		N->max[i]=Jess_max(K->nodes[left].max[i],K->nodes[right].max[i]);
 	}
 
 	// We're done...
-
-	return N;
+	return k;
 }
 
-static void KdTreeNode_free(KdTreeNode *N)
-{
-	if(N)
-	{
-		KdTreeNode_free(N->left);
-		KdTreeNode_free(N->right);
-		free(N);
-	}
-}
+#undef Jess_min
+#undef Jess_max
 
 // ==================================================================
 
