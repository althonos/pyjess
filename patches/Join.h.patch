diff --git a/src/Join.h b/src/Join.h
index b43a6a3..6a60803 100644
--- a/src/Join.h
+++ b/src/Join.h
@@ -10,6 +10,7 @@
 #ifndef JOIN_H
 #define JOIN_H
 
+#include "Annulus.h"
 #include "Region.h"
 
 // ==================================================================
@@ -21,6 +22,22 @@
 
 typedef enum {innerJoin,outerJoin} JoinType;
 
+// ==================================================================
+// type Join
+// ==================================================================
+// count				The number of regions in the join
+// R[k]					The kth region in the join
+// ==================================================================
+
+typedef struct _Join Join;
+
+struct _Join
+{
+	int count;
+    JoinType type;
+	Annulus *R[0];
+};
+
 // ==================================================================
 // Construction methods for region type Join
 // ==================================================================
@@ -28,8 +45,103 @@ typedef enum {innerJoin,outerJoin} JoinType;
 // free(J)					Frees join AND nested regions (J->free)
 // ==================================================================
 
-extern Region *Join_create(Region**,int,JoinType);
-extern void Join_free(Region*);
+extern Join *Join_allocate(int,JoinType);
+extern Join *Join_create(Annulus**,int,JoinType);
+extern void Join_free(Join*);
+
+// ==================================================================
+// Oracles
+// ==================================================================
+
+// int Join_ro(Region *R,double *min,double *max,int dim);
+// int Join_po(Region *R,double *min,double *max,int dim);
+
+// int Join_oro(Region *R,double *min,double *max,int dim);
+// int Join_iro(Region *R,double *min,double *max,int dim);
+// int Join_opo(Region *R,double *x,int dim);
+// int Join_ipo(Region *R,double *x,int dim);
+
+// ==================================================================
+// The oracles
+// ==================================================================
+
+static inline int _Join_oro(Join *J,double *min,double *max,int dim)
+{
+	Annulus* A;
+	int k;
+
+	for(k=0; k<J->count; k++)
+	{
+		A=(Annulus*) J->R[k];
+		if(_Annulus_ro(A,min,max,dim))
+		{
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+static inline int _Join_iro(Join *J,double *min,double *max,int dim)
+{
+	Annulus* A;
+	int k;
+
+	for(k=0; k<J->count; k++)
+	{
+		A=(Annulus*) J->R[k];
+		if(!(_Annulus_ro(A,min,max,dim)))
+		{
+			return 0;
+		}
+	}
+
+	return 1;
+}
+
+static inline int _Join_opo(Join *J,double *x,int dim)
+{
+	Annulus* A;
+	int k;
+
+	for(k=0; k<J->count; k++)
+	{
+		A=(Annulus*) J->R[k];
+		if(_Annulus_po(A,x,dim))
+		{
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+static inline int _Join_ipo(Join *J,double *x,int dim)
+{
+	Annulus* A;
+	int k;
+
+	for(k=0; k<J->count; k++)
+	{
+		A=(Annulus*) J->R[k];
+		if(!(_Annulus_po(A,x,dim)))
+		{
+			return 0;
+		}
+	}
+
+	return 1;
+}
+
+static inline int _Join_ro(Join *J,double *min, double *max, int dim)
+{
+    return (J->type == innerJoin) ? _Join_iro(J,min,max,dim) : _Join_oro(J,min,max,dim);
+}
+
+static inline int _Join_po(Join *J,double *x, int dim)
+{
+    return (J->type == innerJoin) ? _Join_ipo(J,x,dim) : _Join_opo(J,x,dim);
+}
 
 // ==================================================================
 
