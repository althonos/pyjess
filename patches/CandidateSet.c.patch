diff --git a/src/CandidateSet.c b/src/CandidateSet.c
new file mode 100644
index 0000000..235d45d
--- /dev/null
+++ b/src/CandidateSet.c
@@ -0,0 +1,123 @@
+// ==================================================================
+// CandidateSet.h
+// Copyright (c) Jonathan Barker, 2002
+// Copyright (c) Martin Larralde, 2025
+// ==================================================================
+// Implementation of type CandidateSet.
+// ==================================================================
+
+#include <stdlib.h>
+
+#include "CandidateSet.h"
+#include "Atom.h"
+#include "Molecule.h"
+#include "Template.h"
+
+// ==================================================================
+// Methods of type CandidateSet
+// ==================================================================
+
+CandidateSet *CandidateSet_create()
+{
+	CandidateSet *S;
+
+	S = (CandidateSet*)malloc(sizeof(CandidateSet));
+    if(!S) return NULL;
+
+	S->coord = NULL;
+	S->atom = NULL;
+	S->count = 0;
+	S->capacity = 0;
+    
+    return S;
+}
+
+CandidateSet *CandidateSet_reuse(CandidateSet *S, int n)
+{
+	S->count = 0;
+
+	if(S->capacity < n)
+	{
+		S->capacity = n;
+		S->atom = realloc(S->atom,sizeof(Atom*)*n);
+		S->coord = realloc(S->coord,sizeof(double*)*n);
+
+		if(!S->atom || !S->coord)
+		{
+			CandidateSet_free(S);
+			return NULL;
+		}
+	}
+
+	return S;
+}
+
+void CandidateSet_free(CandidateSet *S)
+{
+	if(S)
+	{
+		if(S->atom) free(S->atom);
+		if(S->coord) free(S->coord);
+		free(S);
+	}
+}
+
+// ==================================================================
+// Methods of type CandidateSetArray
+// ==================================================================
+
+CandidateSetArray* CandidateSetArray_create()
+{
+	CandidateSetArray *S;
+
+	S = (CandidateSetArray*) malloc(sizeof(CandidateSetArray));
+    if(!S) 
+		return NULL;
+
+	S->items = NULL;
+	S->count = 0;
+	S->capacity = 0;
+    return S;
+}
+
+void CandidateSetArray_free(CandidateSetArray *C)
+{
+	if(C)
+	{
+		if(C->items)
+		{
+			for(size_t i=0; i<C->count; i++)
+				CandidateSet_free(C->items[i]);
+			free(C->items);
+		}
+		free(C);
+	}
+}
+
+CandidateSet* CandidateSetArray_get(CandidateSetArray *C, int k)
+{
+	if(!C)
+		return NULL;
+
+	if(k>=C->count)
+	{
+		if(C->count>=C->capacity)
+		{
+			C->capacity = C->capacity + (C->capacity >> 3) + 6;
+			C->items = realloc(C->items, C->capacity*sizeof(CandidateSet*));
+			if(!C->items) return NULL;
+		}
+
+		for(int i=k; i<=k; i++)
+		{
+			C->items[C->count] = CandidateSet_create();
+			if(!C->items) return NULL;
+			C->count++;
+		}
+	}
+
+
+	return C->items[k];
+}
+
+// ==================================================================
